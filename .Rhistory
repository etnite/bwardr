geno.in <- read.delim("~/GDrive/Virginia_Tech/Genotyping_Data/TCAP/T3_Downloads/YVP_rrB_geno_imp_070915.hmp.txt")
View(geno.in)
geno <- geno.in + 1                                      #Recode genotypes as 0, 1, 2
geno <- geno/rowMeans(geno)                              #Center SNPs
p <- as.vector(1 + rowSums(geno))/(2 + 2*ncol(geno))
geno <- geno/(sqrt(p*(1 - p)))                           #Normalize SNPs
cov.mat <- cov(geno)                                     #Covariance matrix of centered, normalized SNP matrix
eig.decomp <- eigen(cov.mat)
strat.vecs <- eig.decomp$vectors
strat.vals <- eig.decomp$values
strat.vecs
plot(strat.vecs[, 1], strat.vecs[, 2], xlab = "PC1", ylab = "PC2", pch = 19, cex = 0.75)
setwd("C:/Users/Brian/repos/ERSGGL_lab/nuwwsn_pnuwwsn_fhb_gs/gs_run_files")
library(tidyverse)
library(knitr)
library(rlang)
library(gaston)
library(lme4)
library(rrBLUP)
knitr::opts_chunk$set(echo = TRUE)
set.seed(8)
install.packages("lme4")
library(lme4)
## Input and output files
pheno_file <- "../data/pheno/nuwwsn_pnuwwsn_mpi4_clean_pheno.csv"
geno_file <- "../data/geno/NorthFHB_MAF005_Miss50_Het01_TaxHet02_bp64_ld08_imp.vcf.gz"
out_dir <- "../temp/mpi4_cv_50rep_5fold"
## Select traits to run CV on
traits <- c("HD", "HT", "INCIDENCE", "SEVERITY", "INDEX", "FDK", "ISK", "DON")
## Parameters to filter SNPs after subsetting genotypic matrix
min_maf <- 0.05
max_het <- 0.1
## Cross-validation parameters
repeats <- 50
folds <- 5
#' Generate GxE Plot for a trait
#'
#' @param trait_df - a dataframe or tibble with at least three columns -
#'   GENOTYPE, ENV, and values for a trait of interest
#' @param trait_of_int - string matching the column name for the trait of
#'   interest in trait_df
#' @param min_core - integer specifying the minimum number of "core" genotypes
#'   (i.e. genotypes tested in all environments) required to produce plot. If
#'   the number of core genotypes falls below this number, NULL will be returned
#' @return a ggplot plot object, or NULL
#' @details This function generates GxE plots in a manner similar to that of
#'   Finlay and Wilkinson (1963; https://doi.org/10.1071/AR9630742). Briefly,
#'   a "core" set of genotypes tested across all environments is identified.
#'   The environments are then arranged in increasing order by the mean values
#'   of the core genotypes within each environment, and then a regression is fit
#'   for each individual core genotype.
ge_plot_gen <- function(trait_df, trait_of_int, min_core = 5) {
## Identify and subset core lines
genos_by_env <- list()
for (strat in unique(trait_df$ENV)) {
genos_by_env[[strat]] <- trait_df$GENOTYPE[trait_df$ENV == strat]
}
core_lines <- Reduce(intersect, genos_by_env)
if (length(core_lines >= min_core)) {
filter(trait_df, GENOTYPE %in% core_lines) %>%
select(one_of(c("GENOTYPE", "ENV", trait_of_int))) ->
sub_df
## Here standard evaluation is used (!!sym())
group_by(sub_df, ENV) %>%
summarise(Mean = mean(!!sym(trait_of_int))) %>%
arrange(Mean) %>%
mutate(GENOTYPE = "MEAN") ->
env_order
## Add the within-env means to the data
colnames(env_order)[colnames(env_order) == "Mean"] <- trait_of_int
sub_df <- bind_rows(env_order, sub_df)
sub_df$type <- "entry"
sub_df$type[sub_df$GENOTYPE == "MEAN"] <- "mean"
## Order the environments by their means
env_order <- as.character(env_order$ENV)
sub_df$ENV <- factor(sub_df$ENV, levels = env_order)
sub_df <- sub_df[order(sub_df$ENV), ]
## Generate GxE plot
ggplot(sub_df, aes_string(x = "ENV", y = trait_of_int)) +
geom_smooth(aes(group = GENOTYPE, color = type), method = "lm", size = 0.75, se = FALSE) +
scale_color_manual(values = c(mean = "red", entry = "black")) +
xlab("Environment") +
ylab(trait_of_int) +
theme_bw() +
theme(axis.text.x = element_text(angle=90, vjust = 0.25)) ->
ge_plot
return(ge_plot)
} else {
warning(paste("Number of core genotypes falls below specified threshold for trait", trait_of_int))
return(NULL)
}
}
#' Subset a BED genotypic matrix and create additive relationship matrix
#'
#' @param bed A bed.matrix object created with package 'gaston'
#' @param genos A character vector listing genotypes (i.e. individuals) to
#'   include in the final genotypic matrix
#' @param maf Number between 0 and 0.5 - the minimum minor-allele-frequency
#'   threshold
#' @return An additive relationship matrix (A) created from the subsetted BED
#'   matrix
#' @details This function takes a BED (PLINK binary pedigree/map) file,
#'   optionally subsets individuals from it, optionally filters SNPs by minor-
#'   allele frequency and/or percent heterozygous calls, and then uses the
#'   remaining data to estimate an additive relationship matrix. It is advised
#'   to re-filter SNPs whenever subsetting individuals, as allele frequencies
#'   and the proportion of heterozygous calls may change.
bed2A <- function(bed, genos=NULL, maf=NULL, het=NULL) {
## Perform optional subsetting/filtering
if (!is.null(genos)) { bed <- gaston::select.inds(bed, id %in% genos) }
if (!is.null(maf))   { bed <- gaston::select.snps(bed, maf >= min_maf) }
if (!is.null(het))   { bed <- gaston::select.snps(bed, hz <= max_het) }
bed <- gaston::set.stats(bed, verbose = FALSE)
## "Flip" SNPs for which 2 encodes the major allele
## I'm not sure if this is strictly necessary for making the A matrix or not
gen_mat <- gaston::as.matrix(bed)
gen_mat[, bed@p > 0.5] <- gen_mat[, bed@p > 0.5] - 2
gen_mat <- abs(gen_mat)
A_mat <- rrBLUP::A.mat(gen_mat - 1)
return(A_mat)
}
dir.create(out_dir)
read_csv(pheno_file, guess_max = 5000) %>%
filter(TEST == "MPI4") ->
pheno
geno <- read.vcf(geno_file, verbose = FALSE)
trait_vars <- as.data.frame(matrix(nrow = length(traits), ncol = 5))
colnames(trait_vars) <- c("trait", "n_envs", "geno_var", "res_var", "H2")
rownames(trait_vars) <- trait_vars$trait <- traits
accuracy <- as.data.frame(matrix(nrow = repeats * folds, ncol = length(traits) + 4))
colnames(accuracy) <- c("REPEAT", "FOLD", "nTRAIN", "nVAL", traits)
accuracy$REPEAT <- sort(rep_len(1:repeats, length.out = nrow(accuracy)))
accuracy$FOLD <- rep_len(1:folds, length.out = nrow(accuracy))
traits
t <- "DON"
tmp_phen <- select(pheno, one_of(c("ENV", "GENOTYPE", t)))
tmp_phen <- tmp_phen[!is.na(tmp_phen[t]), ]
if (nrow(tmp_phen) == 0) {
cat("\n\n")
print(paste("No pheno data for trait ", t, ". It is being skipped!", sep = ""))
cat("\n\n")
} else {
## Intersect pheno with geno data
gp_genos <- intersect(geno@ped$id, tmp_phen$GENOTYPE)
tmp_phen <- tmp_phen[tmp_phen$GENOTYPE %in% gp_genos, ]
cat("\n")
print(paste("Environments removed for trait ", t, ":", sep = ""))
print(setdiff(unique(pheno$ENV), unique(tmp_phen$ENV)))
cat("\n")
print(paste("Number environments remaining for trait ", t, ":", sep = ""))
print(length(unique(tmp_phen$ENV)))
## Count genotypes tested within each env.
cat("\n")
print("Genotypes tested per environment:")
table(tmp_phen$ENV) %>%
as.tibble() %>%
rename(ENV = Var1, nGenos = n) %>%
print(n = 200)
#### Calculate genotypic BLUPs, save variances and heritability estimates ####
y <- tmp_phen[[t]]
G <- factor(tmp_phen$GENOTYPE)
E <- factor(tmp_phen$ENV)
## Run the mixed model
mlm <- lmer(y ~ (1|G) + (1|E))
## Extract variance components and number of envs.
vars <- as.data.frame(VarCorr(mlm))
Gvar <- vars[vars$grp == "G", "vcov"]
errvar <- vars[vars$grp == "Residual", "vcov"]
nEnvs <- unlist(summary(mlm))$ngrps.E
## Estimate entry-mean heritability
h2 <- Gvar / ((errvar / nEnvs) + Gvar)
cat("\n")
print(paste("Entry mean heritability for trait ", t, ": ", round(h2, 2), sep = ""))
trait_vars[t, 2:5] <- c(nEnvs, Gvar, errvar, h2)
## Create a GxE plot
cat("\n")
print(paste("GxE plot for trait", t))
ge_plot <- ge_plot_gen(tmp_phen, t)
if (!is.null(ge_plot)){
plot(ge_plot)
} else {
print("Not enough genotypes shared across all envs to create GxE plot")
}
## Extract BLUPs
blups <- data.frame(rownames(ranef(mlm)$G), ranef(mlm)$G)
colnames(blups) <- c("GENOTYPE", t)
#### Estimate the additive relationship matrix ####
A <- bed2A(bed = geno, genos = blups$GENOTYPE, maf = min_maf, het = max_het)
for (r in c(1:repeats)) {
## Randomize folds
blups$FOLDS <- sample(rep_len(1:folds, length.out = nrow(blups)), size = nrow(blups))
for (f in c(1:folds)) {
## Assign training and validation sets
train_set <- blups$GENOTYPE[blups$FOLDS != f]
valid_set <- blups$GENOTYPE[blups$FOLDS == f]
accuracy[folds*(r - 1) + f, "nTRAIN"] <- length(train_set)
accuracy[folds*(r - 1) + f, "nVAL"] <- length(valid_set)
## Run mixed model, calculate correlation
masked <- blups
masked[masked$GENOTYPE %in% valid_set, t] <- NA
kin_blup_out <- kin.blup(masked, geno = "GENOTYPE", pheno = t, K = A)
accuracy[folds*(r - 1) + f, t] <- cor(kin_blup_out$g[valid_set],
blups[blups$GENOTYPE %in% valid_set, t],
use = "complete")
} ## End folds loop
} ## End repeats loop
} ## End if...else data presence test
library(lme4)
install.packages("nloptr")
library(lme4)
gp_genos <- intersect(geno@ped$id, tmp_phen$GENOTYPE)
bed <- select.inds(geno, id %in% gp_genos)
length(unique(tmp_phen$GENOTYPE))
gmat <- as.matrix(bed)
dim(gmat)
test <- gmat
test[1:5, 1:5]
test <- tr(test)
test <- t(test)
test <- test[1:500,]
rowMeans(test)
geno <- test
geno <- apply(geno, 1, function(x) {x - rowMeans(x, na.rm = TRUE)})
geno <- apply(geno, 1, function(x) {x - mean(x, na.rm = TRUE)})
rowMeans(geno)
View(geno)
geno <- test
View(geno)
geno <- apply(geno, 1, function(x) {x - mean(x, na.rm = TRUE)})
rowMeans(geno)
colMeans(geno)
geno <- t(geno)
geno <- test
View(test)
col_names <- colnames(geno)
geno <- apply(geno, 1, function(x) {x - mean(x, na.rm = TRUE)})
geno[is.na(geno)] <- 0
identical(rownames(geno), col_names)
if(identical(rownames(geno), col_names)) {
geno <- t(geno)
}
p <- as.vector(1 + rowSums(geno))/(2 + 2*ncol(geno))
geno <- apply(geno, function(x) {x / sqrt(p * (1 - p))})
geno <- apply(geno, 1, function(x) {x / sqrt(p * (1 - p))})
warnings()
p
geno <- test
geno <- t(geno)
View(geno)
geno <- geno - colMeans(geno, na.rm = TRUE)
colMeans(geno)
geno <- test
geno <- sapply(geno - colMeans(geno, na.rm = TRUE))
geno <- apply(geno, 2, function(x) {x - mean(x, na.rm = TRUE)})
geno <- test
geno <- sapply(geno - colMeans(geno, na.rm = TRUE))
geno <- apply(geno, 1, function(x) {x - mean(x, na.rm = TRUE)})
geno[is.na(geno)] <- 0
if(identical(rownames(geno), col_names)) {
geno <- t(geno)
}
p <- as.vector(1 + rowSums(geno))/(2 + 2*ncol(geno))
denom <- sqrt(p * (1 - p))
geno <- t(t(geno) / denom)
cov_mat <- cov(geno)
eig_decomp <- eigen(cov_mat)
strat.vecs <- eig.decomp$vectors
strat.vecs <- eig_decomp$vectors
strat.vals <- eig_decomp$values
plot(strat.vals/sum(strat.vals), xlab = "PC", ylab = "Portion Variance Explained",
pch = 21, col = "black", bg = "slateblue")
plot(strat.vecs[, 1], strat.vecs[, 2], xlab = "PC1", ylab = "PC2", pch = 19, cex = 0.75)
library(devtools)
setwd("C:/Users/Brian/repos/bwardr")
check()
install.packages("vcfR")
check()
